# 仕組み

* 核となるアイディアは, 以下のようなコードで説明される

    ```
    if (x < array1_size)
      y = array2[array1[x] * 4096];
    ```
* プログラムの意図(ソフトウェア的な立場)としては, `x >= array1_size` の時, 2行目は実行されない
* 一方で, 一定の条件を満たせば **投機的実行** によってハードウェアレベルで2行目も実は実行されることがある
  * 当然, 成立しないif文の中身(2行目)が実行されるのは本来期待する動作ではないので, 投機的実行の説明で述べたように, メモリの内容が書き換えられるようなことはない
  * つまり, この2行より後に `y` を参照していたとして, `x >= array1_size` の際に陰ながら実行されていた2行目の処理が, その際に読み出される `y` の値に影響することはない
* 後で不要とわかった投機的実行の処理は, メモリには影響しないが, **CPUのキャッシュには影響を残す**
  * [先](background/speculative-execution.md)のたとえ話になぞらえれば, 直接客人からは見えないが台所には急須が出しっぱなしになっていたりと, お茶を準備していた事の影響が残っている
  * コード例では, 2行目が投機的に実行されていると, `array2` が確保しているメモリ領域のうち, `array1[x] * 4096` のインデックスが指し示すアドレスのデータはキャッシュに乗ってきたままになる
* この事を利用し, 既存のFLUSH+RELOADの仕組みで, アクセスしたアドレスは特定できる
  * CPUのキャッシュの中身を直接眺めることはできないが, キャッシュ上にデータが存在するかどうかは, アクセス速度の差により推測可能
  * 事前に`array2[array1[x] * 4096]` が指し示す可能性のある領域をキャッシュから排除した上でコードの実行を待ち, その後 `array2` を片っ端から読んでいけば, どこかだけロードが早いという状況になる可能性が高く, その位置から `array1[x]` の内容がわかってしまう

## 基本的な仕組みのまとめ
1. 投機的実行により本来実行されないはずの処理が実行されることがある
1. 実行されないはずの処理の影響は直接観測できないが, キャッシュには影響が残っている
1. キャッシュ上の存在有無はロード等に要する時間から間接的に観測可能
