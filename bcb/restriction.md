# 攻撃の条件・制約

```
if (x < array1_size)
  y = array2[array1[x] * 4096];
```

* コンセプトは説明した通りだが, 実際に意味のある攻撃として成立するには前提,条件,制約が多い
  * これ自体はkernelの権限を奪取するというような話ではないので, (Meltdownの事を考えなければ)kernel空間のメモリが読みたければ**kernel modeで実行する必要**がある
  * kernelの権限で任意コード実行できる状況ならSpectreにかかわらずメモリを読み放題なので, 何の旨味もない

 ![virtual address space](https://pentesterslife.files.wordpress.com/2017/11/fig112.png) [画像出典](https://pentesterslife.blog/2017/11/24/x64-egg-hunting-in-linux-systems/)

* 任意コードは実行できないが, `if (x < array1_size)` のような境界値チェックにより安全が確認された上であれば, 権限付きでコードを実行することができるようなケースに, Spectreのつけいる隙がある
  * 投機的実行により境界値チェックをすり抜けてユーザーのコードが陰ながら実行されてしまい, その中で値を読み出しキャッシュ上に値に応じた痕跡を残すことが可能
  * Project Zero では extended BPF という, ユーザーのコードを静的に安全性を確認した上でkernelで実行する仕組み(iptablesに代わるfirewallとして注目されていたりする)を利用
  * ソフトウェア内に**このようなパターンの処理が存在するかどうか**が影響有無を分ける
* さらに, 投機的実行により(ソフトウェア視点では)本来実行されるべきでない処理を実行させるのも, 無条件にできるわけではない
  * 分岐条件に必要な値をキャッシュから取得されないようにし, 投機的に実行できるコードの量を稼ぐ必要がある
    * 近くの値を書き換えることで, キャッシュコヒーレンシ担保の仕組みによりメモリまで読みに行くように仕向ける...など
  * 投機的実行する内容を誘導するために, **分岐予測を制御する必要**がある
  * 投機的に実行しているコードの中で使用する値については, アクセスの痕跡を残すための領域( `array2` 配列が確保している領域) を除いてキャッシュに乗っている必要がある
  * アクセスの痕跡を残すためのメモリ領域については, 痕跡を確認するために後からアクセスできないといけないし, キャッシュから事前にフラッシュしてキレイにしておく必要もある
    * ちなみに, コードの2行目の4096倍はキャシュラインが被らないようにするための措置
      * キャッシュライン = キャッシュは1byte単位ではなく, 64byte等の単位でキャッシュをしており, そのひとかたまり(+メタデータ)をキャッシュラインと呼ぶ
