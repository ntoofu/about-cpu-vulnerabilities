# 仕組み

```
  x = *(kernelのメモリ領域のアドレス);    // raise SEGV
  y = *(userが確保済みのメモリ領域のアドレス先頭 + x * 64);

SEGVのハンドラ:
  // userが確保済みのメモリ領域を順番にアクセスし, 速度からxを推定
```

* ユーザープログラムから, kernelのメモリ領域を読みに行く
  * このアクセスは許されないため, 例外を発生させSegmentation Faultとなるのが通常の流れ
  * したがって本来は後続の処理は行われない
* 条件が揃っていると, **Out-of-Order実行によりメモリ領域を読みに行った後の処理が行われる**
  * メモリ領域を読み出す命令より手前の命令を完了させないことで, 読み出しの命令も完了したことにできないようにして, 例外処理への移行を抑止
    * 事前に攻撃と関係ない演算リソースのreservation stationを埋めて置くことで実現
* 後続の処理ではVariant 1などと同様, 後でその結果を読み取れるように, 読み出した値を元にメモリアクセスをしてキャッシュに痕跡を残す
