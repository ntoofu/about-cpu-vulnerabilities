# Kernelのメモリ管理

* Meltdown対策であるPTI(page table isolation)を導入する前のLinux kernelにおけるメモリマップの特徴
  * プロセスごとにpage tableは1つ
    * kernelの処理実行中も, ユーザープログラムの処理実行中も, 同一のpage table
  * メモリ空間の低位アドレス側にユーザープログラムが使う領域, 高位アドレス側にカーネルが使う領域を割り当て
    * カーネルが使うpageはU/Sフラグをクリアしてあるため, ユーザーがアクセスしてもsegmentation faultに終わる
* 頻繁にプロセスを切り替えて処理をするシステムにおける処理効率化の観点で設計されたメモリマップである
  * どのプロセスを実行中か, ユーザープロセスかkernelのどちらの処理を実行中かにかかわらず, kernel用のメモリ領域の割当が変わらないが肝

## TLB

* 工夫がなければ, 仮想 -> 物理アドレスの変換は非常に時間がかかる
  * ページテーブルは多階層になっているため, ある仮想アドレスを物理アドレスに変換するのに, 複数回のメモリアクセスが必要
    * 変換後のアドレスを求めるために多階層の構造をたどる処理を, `page walk` と呼ぶ
* 頻繁に発生する仮想アドレスから物理アドレスの変換に時間がかかるのは致命的
* 変換の速度を改善するため, アドレス変換のキャッシュとして `TLB` (translation look-aside buffer) が設けられている
  * TLBも命令/データを保持するキャッシュと同じように多階層化されていたりする
* ページテーブルの中身が変わればその分をflushする必要があり, ページテーブルの変更が少ないほうがキャッシュに乗り続けることができ性能的なメリットがある
  * ユーザープロセスの処理とkernelの処理で共通のページテーブルを使うことで, 変更を抑えている
  * ページテーブル自体が切り替えられる時にx86では基本的にTLB全体をflushするが, Globalフラグの立っているページはflushされないようになっており, kernelのページはプロセス切り替えを経てもTLBに乗り続ける
