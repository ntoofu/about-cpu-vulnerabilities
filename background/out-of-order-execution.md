# Out-of-Order実行

## スーパースカラプロセッサ
* 単純に一連の処理をパイプライン化しただけでは, 性能向上に上限がある
  * 分岐予測などはパイプラインをいかにストールさせず稼働率を高めるか, という観点で性能向上を狙っていた
  * パイプラインストールがなく100%稼働していても, 1クロック1命令実行という上限は超えられない
* そこで出てきた考え方は, 1クロックに複数命令を処理できないかということだった
* 命令のデコード時に一回に複数命令をデコードし, 演算器も複数搭載してやれば, 1クロックあたりに実行できる命令数 = IPC (Instruction per Clock) 1以上を目指せる
  * 何の演算をするためのユニットを何個搭載するか, というのもCPUのアーキテクチャ設計の要素になってくる

## 命令の並び替え
* スーパースカラプロセッサでは, 並列的に複数命令を処理しようとするため, データの依存性や演算器が埋まっているなどの事情で処理が進められない事態が起こる
  * 依存関係 = 同じレジスタを操作する (Read after Write, Write after Read, Write after Write)
* 依存関係があっても, うまく命令間でデータを引き渡して最終的に不整合が発生しないようにすれば, 処理できない命令より後ろの命令を先に実行することも出来るはず
  * 順序を守らず = Out-of-Order に実行
  * 方式は色々あるが, reorder bufferを用いる方式が多い

## reorder buffer
* 依存関係がある命令もOut-of-Orderに実行したい
* そのために, 命令をデコードした後スケジューラにより依存関係を管理される
  * スケジューラは, 命令に対応するリソース（整数演算器, 浮動小数演算器, ...）ごとに存在する reservation station というバッファに, 命令の種類やオペランドに関する情報を配置する
    * 各演算器は, reservation stationの中にオペランドが確定したものがあれば処理していく
  * reorder bufferという一時的な記憶領域のうち空いているエントリを割り当て, 演算器はレジスタではなくreorder bufferに結果を書き込む
    * 先行の命令も完了し, 結果が確定すればレジスタに内容を反映(commit)する仕組み
