# Out-of-Order実行

## スーパースカラプロセッサ
* 単純に一連の処理をパイプライン化しただけでは, 性能向上に上限がある
  * 分岐予測などはパイプラインをいかにストールさせず稼働率を高めるか, という観点で性能向上を狙っていた
  * パイプラインストールがなく100%稼働していても, 1クロック1命令実行という上限は超えられない
* そこで出てきた考え方は, 1クロックに複数命令を処理できないかということだった
* 命令のデコード時に一回に複数命令をデコードし, 演算器も複数搭載してやれば, 1クロックあたりに実行できる命令数 = IPC (Instruction per Clock) 1以上を目指せる
  * 何の演算をするためのユニットを何個搭載するか, というのもCPUのアーキテクチャ設計の要素になってくる

## 命令の並び替え
* スーパースカラプロセッサでは, 並列的に複数命令を処理しようとするため, データの依存性や演算器が埋まっているなどの事情で処理が進められない事態が起こる
  * 依存関係 = 同じレジスタを操作する (Read after Write, Write after Read, Write after Write)
* 依存関係があっても, うまく命令間でデータを引き渡して最終的に不整合が発生しないようにすれば, 処理できない命令より後ろの命令を先に実行することも出来るはず
  * 順序を守らず = Out-of-Order に実行
  * 方式は色々あるが, reorder bufferを用いる方式が多い

## reorder buffer
* 依存関係がある命令もOut-of-Orderに実行したい
* そのために, 命令をデコードした後, 依存関係を管理される
  * 命令に対応するリソース（整数演算器, 浮動小数演算器, ...）ごとに存在する reservation station というバッファに, 命令の種類やオペランドを配置する(**issue**)
    * この処理はあくまで命令の順に従って(in-orderに)行われる
    * 各演算器は, reservation stationの中にオペランドが確定したものがあれば処理していく
  * reorder buffer (ROB)という一時的な記憶領域のうち空いているエントリを割り当て, 演算器はレジスタではなくreorder bufferに結果を書き込む
    * issueの際に命令の結果を書き込む先として, 順番にエントリを割り当てる
      * 本来結果が書き込まれるべきレジスタと割り当てたエントリの対応もメモしておく
    * issueの際にオペランドの値が確定していない場合(先行の命令の結果待ちの場合)も, 対応するreorder bufferのエントリを示すtagをreservation stationに送る
      * レジスタとエントリの対応メモに基づいて, どのエントリを使うかは判定される
    * ring buffer状の構造をしたreorder bufferのheadのエントリについて, 値が書き込まれた状態であればその内容をレジスタに反映(commit)する仕組み
      * より後方のエントリに値が書き込まれても, レジスタへの反映は必ずheadから行われるため, 最終的に得られる結果はin-orderに反映されていく
      * また, reservation stationにも通知し, 結果を待っている状態だったオペランドを埋めさせる
    * commitできればreorder bufferから消える

### reorder buffer方式の動作まとめ
* 命令を順番に担当者(演算器等のリソース)のToDoリスト(reservation station)に書き込みに行く
  * その際, 通し番号も発行する
  * 命令の実行に必要な引数の値もToDoリストに書くが, 別の命令の結果依存であれば, その命令の通し番号を書いておく
* 担当者はToDoリストの中で引数が確定したものを手が空き次第随時処理し, 結果を通し番号とともに全体に通知する
* 担当者はToDoリストの中で引数として待っている命令が終わっていることを知ると, その結果を引数として埋める
* ROBは通し番号に対応する命令とその結果と状態を管理しており, 処理が完了している最も若番のものから結果を確定
  * 確定した結果はレジスタに反映させる
