# プロセス間のアドレス空間分離

## 背景

* 1つのコンピュータを複数人で効率的に共用するために, time-sharingなOSが生まれた
  * time-sharing system: 時間を細かい単位に分割し, それぞれの単位で1つのユーザーを割り当てることで, 1つしか無い資源を複数人が共用できる
  * 今でも様々なプログラム(プロセス)を同時に走らせるのに都合がよく, 一般的なOSはtime-sharing system
* time-sharing OSとして, メモリを何らかの単位で分割してプロセスごとに使用してよい場所を割り当てる方式が考えられるが, プロセス間で干渉しうる問題がある
  * 他にもメモリ全てをディスク等の別の記憶媒体に移すという方法もあり得たが, プロセスの切り替えに時間を要してしまう
  * プログラムがバグっていて本来あり得ないアドレスにアクセスしたら, 別のプロセスが使用中のデータを読み書きしてしまった...なんてことに成りかねない

## 仮想記憶
* プロセスごとに, 物理的なメモリの一部を割り当てる点は元の発想と同じだが, プロセスからは仮想的なアドレス空間を専有しているように見せる方法
* あるプロセスが自身の仮想アドレス空間内でどれだけ好き勝手にアクセスしても, 割り当てられた物理メモリにしかアクセスできない
* 仮想アドレス(プログラムが利用するアドレス) -> 物理アドレス(実際のメモリ上のアドレス) の変換は 普通ハードウェアレベルで(MMUというユニットにて)実行され, その制御(変換のルールの変更など)はOSが行う
* 本題からは逸れるが, DRAM上の内容を補助記憶装置に退避させる(swap)のためにも活用される
* 現代のコンピュータで広く使われている

## paging
* 仮想記憶を実現するために, pagingという仕組みがよく使われる
  * segmentationという仕組みもあるが, 古いシステムで使っていたもので, Linuxなどではほぼ使っていない
* 物理/仮想アドレス空間を一定のサイズの **page** という細かな単位に分ける
  * 標準的なページサイズは 4096byte
  * 近年のCPUはより大きなページサイズをサポートしており, OSも対応すれば利用可能ではある(Linuxの`HugePages`など)
* **page table** に基づいて, 仮想アドレス空間のページは, 物理アドレス空間のページと紐付けられる
  * page table自体はメモリ上に保持されている
  * 広大な仮想アドレス空間を高速に検索したいが, page table自体のメモリ消費も抑えたいため, 配列を階層的に並べたようなデータ構造によって実現する
  * page tableのエントリには, 仮想ページに対応する物理ページの情報だけでなく, アクセス制御等のためのメタデータ(フラグ)が含まれている
* OSはこのpage tableの設定を上手く行うことで, プロセス間やユーザーからカーネルへのメモリの読み書きが起こらないように制御している
  * プロセスごとにpage tableを用意し, プロセスの切り替えに併せてpage tableも切り替える
  * OSが利用するコードは特権状態(kernel mode)でないと読めないフラグの設定

